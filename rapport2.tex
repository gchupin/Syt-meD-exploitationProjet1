\documentclass[10pt, a4paper]{article}

\usepackage [T1]{fontenc}
\usepackage [utf8]{inputenc}
\usepackage [francais]{babel}
\usepackage {graphicx}

\title {Rapport Devoir 2 - Système d'exploitation}
\author {CHUPIN Guillaume et PILLEUX Julien}

\begin {document}
\maketitle

\thispagestyle {empty}
\newpage
\tableofcontents
\newpage


\section {Bilan}
\subsection {Multithreading dans les programmes utilisateurs}

% Sous section du schmurtz.
Nous avons commencé par implémenter une structure appelée ``schmurtz'' pour pouvoir donner à un thread plus d'un paramètre à la fois. Cette structure est assez simple, elle est constituée de trois champs correspondants à trois entiers:
% Quatre champs de la structure.
\begin {itemize}
\item {Un premier entier qui correspond à l'adresse de la fonction que l'on veut que le thread exécute}
\item {Un second entier qui correspond à l'adresse de la liste des arguments de la fonction précédemment citée}
\item {Un troisième entier qui correspond au numéro de page où est stocké la pile}
\item {Un dernier entier correspondant aux pointer de fonction de ThreadExit}
\end {itemize}

% Sous section de do_ThreadCreate.
Cette structure est alors principalement utilisée dans la fonction do\_ThreadCreate qui instancie un thread de Nachos puis une structure schmurtz. De plus, la fonction initialise les champs de la structure avec l'adresse de la fonction ainsi que celle des arguments de cette fonction qui sont donnés en paramètre. Pour le dernier champ de la structure, on fait appel à la fonction AllocateUserStack sur la quelle nous reviendrons plus tard dans ce rapport. Avant de lancer le thread, la fonction vérifie si la pile qui lui est dédié est bien allouée, si ça n'est pas le cas, elle désalloue le thread et la structure instanciés au début de la fonction et renvoie -1. Si elle a réussi à allouer la pile du thread alors elle appelle la fonction StartUserThread et retourne 0 pour signifier que le thread est correctement lancé.
\newline

% Sous section de StartUserThread.
Dans la fonction StartUserThread nous commençons par initialiser tout les registres à 0, puis nous initialisons alors le registre liés à la pile, le registre du compteur ordinal, le registre de la prochaine instruction et le registre contenant les arguments de la fonction. Toutes ces initialisations sont faites grâce à la structure schmurtz que nous donnons en paramètre à la fonction. Nous terminons alors par désallouer la structure, puis nous lançons le thread. Nous avons ensuite créé un appel système ThreadExit lié à une fonction do\_ThreadExit qui ne faisait qu'appeler la méthode Finish sur le currentThread et désallouer l'espace d'adressage de ce même thread.

\subsection {Plusieurs threads par processus}

% Sous section synchPutChar et synchGetChar.
Dans le but d'assurer que l'exécution des fonctions SynchPutChar et SynchGetChar, nous avons rajouter à l'aide de sémaphores, des verrous autour du code de celles-ci. Nous avons déclaré un sémaphore par fonction, appelés mutexPutChar, mutexPutString, mutexGetString et mutexGetChar, que nous avons tout les 4 initialisés à 1 pour garantir l'exclusion mutuelle de ces fonctions. % Je ne suis plus très sûr de quoi répondre pour la II-1

Pour l'implémentation de plusieurs threads, nous avons rencontrer quelques soucis que nous détaillerons dans la section suivante.

% BitMap
Pour l'allocation de plusieurs threads, nous avons dû améliorer notre fonction AllocateUserStack. Pour ce faire nous avons utilisé la classe BitMap. Nous avons commencé par ajouter une donnée membre pour chaque thread qui servira à se souvenir du numéro de la page mémoire qu'il utilise. Avec cette donnée membre, nous avons une fonction qui transforme le nombre de la page en adresse. Dans la fonction AllocateUserStack, nous cherchons dans un premier temps la première page disponible dans la BitMap, nous effectuons d'ailleurs cette recherche dans des Sémaphores pour garantir l'accès unique à un emplacement de la BitMap. Ensuite nous retournons alors l'emplacement libre. Nous vérifions alors que l'adresse que nous renvoie la fonction est valide, et si ça l'est nous continuons alors notre allocation comme avant.\newline

% Les exercices bonus.
Pour la terminaison automatique des threads, nous avons ajouté à la fonction ThreadCreate mips une ligne permettant de charger l'adresse de la fonction ThreadExit en troisième paramètre. Nous avons alors modifié nos fonctions do\_ThreadCreate en ajoutant à notre structure schmurtz un champ 'exit' qui contiendra l'adresse de la fonction ThreadExit qui est alors passée à la fonction StartUserThread qui la récupère et la met dans le registre 31, qui correspond à l'adresse de retour de la fonction. Nous avons également ajouté une macro afin que l'utilisateur ne voit pas ce stratagème.\newline
Pour donner à l'utilisateur un accès aux sémaphores, nous avons dans un premier temps allouer un tableau de Sémaphores de taille fixe, puis un type sem\_t qui correspondra à l'indice d'un Sémaphore dans le tableau. Ensuite, nous avons implémenté 4 appels systèmes :
\begin {itemize}
\item {Les appels systèmes P et V prennent tout les deux un sem\_t en paramètre et font respectivement P et V sur les Sémaphores correspondant au sem\_t en paramètre}
\item {L'appel système SemCreate qui cherche dans le tableau le premier emplacement vide, grâce à une bitmap, pour allouer un Sémaphore avec la valeur passée en paramètre. L'utilisateur récupère alors le sem\_t correspondant dans le retour de la fonction.}
\item {L'appel système SemDelete ne fait que delete le Sémaphore à la case sem\_t et également le retirer de la bitmap}
\end {itemize}


\section {Points délicats}

Nous avons effectivement rencontré des problèmes lors de l'implémentation de plusieurs threads au sein de Nachos. Le système de comptage n'a pas été le point le plus difficile, nous avons implémenté un compteur entier sous forme de variable globale que nous incrémentons à la création d'un thread et que nous décrémentons lors de sa désallocation. Le point le plus délicat a été de protéger ces opérations lors de leur exécution par plusieurs threads. Nous avons fait plusieurs essais non concluants lors du placement de sémaphores, nous avons fini avec la configuration suivante :\newline
Un Sémaphore entourant simplement l'incrémentation de notre variable globale nb\_thread, puis un deuxième sémaphore autour de la décrémentation de cette même variable. Pour faire en sorte d'attendre que tous les threads soient arrêtés lors de la terminaison du thread père, nous avons utilisé un deuxième Sémaphore, dans l'appel système Exit, nous avons mis une boucle while qui fait P sur ce Sémaphore dans que notre variable global nb\_thread n'est pas nulle. Nous appelons V sur ce même Sémaphore lors de la libération d'un thread, juste après la décrémentation de nb\_thread, cet appel V étant aussi protégé par le même sémaphore que celui de la décrémentation.\\

\section {Limitations}
\begin {itemize}
\item L'écriture de SynchPutChar et SynchPutString peuvent ce mélanger car ils n'utilisent pas les même sémaphores, donc ils ne s'excluent pas mutuellement, mais ce n'est pas un gros problème, car on peut utiliser SynchPutString au lieu de SynchPutChar est le problème est réglé.
\item Quand un getchar est suivi par un getstring ce dernier va récupérer l'excédent de l'entrée de getchar, ce qui inclut le retour a la ligne que l'on utilise pour valider l'entrer, comme précédemment on peut tout simplement utiliser seulement getstring et le problème est réglé.
\item L'utilisateur ne peut avoir que 10 sémaphores, ce qui nous semble suffisant pour l'instant.
\item On ne peut qu'avoir 4 threads simultanément, donc si l'utilisateur devra faire attention à n'avoir que 4 threads de lancé en même temps, en utilisant une sémaphore par exemple.
\end {itemize}
\section {Tests}
Voici les différents programme test que nous avons crées:
\begin {itemize}
\item\textbf {makethread.c : } Nous avons crées 6 threads, sachant que l'on ne peut en avoir que 4 simultanément, qui vont chacun affiché 10 fois un caractère propre à chaque thread pour voir facilement, combien de thread sont crée et le nombre de caractère écrit pour chaque thread. 
\item\textbf {semaphore.c : }Nous avons reprit test précédent mais nous avons crée une sémaphore qui fait exécuter un seul thread à la fois?
\item\textbf {thread.c : }Nous avons lancé plusieurs thread qui exécute chacun vont lancé soit GetSting, soit PutString, soit PutChar ou GetChar pour voir si ces fonctions gère correctement les appels concurrents.  
\item\textbf {threadgetint.c : }Pour ce test, nous avons plusieurs thread qui vont lancé GetInt ou PutInt afin de voir si les appels concurrents sont également bien traité.
\end {itemize}

\end{document}

